
======

This codebase has been generated by [Autostrada](https://autostrada.dev/).

Getting started
---------------

Make sure that you're in the root of the project directory and run the `cmd/api` application using `go run`:

    
    $ go run ./cmd/api
    

If you make a request to the `GET /status` endpoint using `curl` you should get a response like this:

    
    $ curl -ik https://localhost:4444/status
    HTTP/2 200 
    content-type: application/json
    content-length: 23
    date: Mon, 09 May 2022 20:48:13 GMT
    
    {
        "Status": "OK",
    }

Note: make sure to use the `-k` flag to accept self-signed TLS certificates.

Project structure
-----------------

Everything in the codebase is designed to be editable. Feel free to change and adapt it to meet your needs.

**`cmd/api`**

Your application-specific code (handlers, routing, middleware, helpers) for dealing with HTTP requests and responses.

`↳ cmd/api/errors.go`

Contains helpers for managing and responding to error conditions.

`↳ cmd/api/handlers.go`

Contains your application HTTP handlers.

`↳ cmd/api/main.go`

The entry point for the application. Responsible for parsing configuration settings initializing dependencies and running the server. Start here when you're looking through the code.

`↳ cmd/api/middleware.go`

Contains your application middleware.

`↳ cmd/api/routes.go`

Contains your application route mappings.

**`internal`**

Contains various helper packages used by the application.

`↳ internal/cookies`

Contains helper functions for reading/writing signed and encrypted cookies.

`↳ internal/request/`

Contains helper functions for decoding JSON requests.

`↳ internal/response/`

Contains helper functions for sending JSON responses.

`↳ internal/server/`

Contains a helper function for starting and gracefully shutting down the server.

`↳ internal/validator/`

Contains validation helpers.

`↳ internal/version/`

Contains the application version number definition.

**`tls`**

Contains TLS certificates.

Configuration settings
----------------------

Configuration settings are managed via command-line flags in `main.go`.

You can try this out by using the `-addr` flag to configure the network address that the server is listening:

    
    $ go run . --addr=:9999
    

Feel free to adapt the `main()` function to parse additional command-line flags and store their values in the `config` struct. For example, to add a configuration setting to enable a 'debug mode' in your application you could do this:

    
    type config struct {
        addr string
        debug bool
    }
    
    ...
    
    func main() {
        var cfg config
    
        flag.StringVar(&cfg.addr, "addr", ":4444", "server address")
        flag.BoolVar(&cfg.debug, "debug", false, "enable debug mode")
    
        flag.Parse()
    
        ...
    }
    

If you don't want to use command-line flags for configuration that's fine. Feel free to adapt the code so that the `config` struct is populated from environment variables or a settings file instead.

Creating new handlers
---------------------

Handlers are defined as `http.HandlerFunc` methods on the `application` struct. They take the pattern:

    
    func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
        // Your handler logic...
    }
    

Handlers are defined in the `cmd/api/handlers.go` file. For small applications, it's fine for all handlers to live in this file. For larger applications (10+ handlers) you may wish to break them out into separate files.

Handler dependencies
--------------------

Any dependencies that your handlers have should be initialized in the `main()` function `cmd/api/main.go` and added to the `application` struct. All of your handlers, helpers and middleware that are defined as methods on `application` will then have access to them.

You can see an example of this in the `cmd/api/main.go` file where we initialize a new `logger` instance and add it to the `application` struct.

Creating new routes
-------------------

[Flow](https://github.com/alexedwards/flow/) is used for routing, but it's fine to swap to a different router if you want.

Routes are defined in the `routes()` method in the `cmd/api/routes.go` file. For example:

    
    func (app *application) routes() http.Handler {
        mux := flow.New()
        
        mux.HandleFunc("/your/path", app.yourHandler, "GET")
        
        return mux
    }
    

For more information on using flow and example usage, please see the [official documentation](https://github.com/alexedwards/flow/).

Adding middleware
-----------------

Middleware is defined as methods on the `application` struct in the `cmd/api/middleware.go` file. Feel free to add your own. They take the pattern:

    
    func (app *application) yourMiddleware(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Your middleware logic...
            next.ServeHTTP(w, r)
        })
    }
    

You can then register this middleware with the router using the `Use()` method:

    
    func (app *application) routes() http.Handler {
        mux := flow.New()
        mux.Use(app.yourMiddleware)
        
        mux.HandleFunc("/your/path", app.yourHandler, "GET")
        
        return mux
    }
    

It's possible to use middleware on specific routes only by creating route 'groups':

    
    func (app *application) routes() http.Handler {
        mux := flow.New()
        mux.Use(app.yourMiddleware)
        
        mux.HandleFunc("/your/path", app.yourHandler, "GET")
    
        mux.Group(func(mux *flow.Mux) {
            mux.Use(app.yourOtherMiddleware)
        
            mux.HandleFunc("/your/other/path", app.yourOtherHandler, "GET")
        })
        
        return mux
    }
    

Note: Route 'groups' can also be nested.

Sending JSON responses
----------------------

JSON responses and a specific HTTP status code can be sent using the `response.JSON()` function. The `data` parameter can be any JSON-marshalable type.

    
    func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
        data := map[string]string{"hello":  "world"}
    
        err := response.JSON(w, http.StatusOK, data)
        if err != nil {
            app.serverError(w, r, err)
        }
    }
    

Specific HTTP headers can optionally be sent with the response too:

    
    func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
        data := map[string]string{"hello":  "world"}
    
        headers := make(http.Header)
        headers.Set("X-Server", "Go")
    
        err := response.JSONWithHeaders(w, http.StatusOK, data, headers)
        if err != nil {
            app.serverError(w, r, err)
        }
    }
    

Parsing JSON requests
---------------------

HTTP requests containing a JSON body can be decoded using the `request.DecodeJSON()` function. For example, to decode JSON into an `input` struct:

    
    func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
        var input struct {
            Name string `json:"Name"`
            Age  int    `json:"Age"`
        }
    
        err := request.DecodeJSON(w, r, &input)
        if err != nil {
            app.badRequest(w, r, err)
            return
        }
        
        ...
    }
    

Note: The target decode destination passed to `request.DecodeJSON()` (which in the example above is `&input`) must be a non-nil pointer.

The `request.DecodeJSON()` function returns friendly, well-formed, error messages that are suitable to be sent directly to the client using the `app.badRequest()` helper.

Validating JSON requests
------------------------

The `internal/validator` package includes a simple (but powerful) `validator.Validator` type that you can use to carry out validation checks.

Extending the example above:

    
    func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
        var input struct {
            Name      string              `json:"Name"`
            Age       int                 `json:"Age"`
            Validator validator.Validator `json:"-"`
        }
    
        err := request.DecodeJSON(w, r, &input)
        if err != nil {
            app.badRequest(w, r, err)
            return
        }
    
        input.Validator.CheckField(input.Name != "", "Name", "Name is required")
        input.Validator.CheckField(input.Age != 0, "Age", "Age is required")
        input.Validator.CheckField(input.Age >= 21, "Age", "Age must be 21 or over")
    
        if input.Validator.HasErrors() {
            app.failedValidation(w, r, input.Validator)
            return
        }
    
        ...
    }    
    

The `app.failedValidation()` helper will send a `422` status code along with any validation error messages. For the example above, the JSON response will look like this:

    
    {
        "FieldErrors": {
            "Age": "Age must be 21 or over",
            "Name": "Name is required"
        }
    }    
    

In the example above we use the `CheckField()` method to carry out validation checks for specific fields. You can also use the `Check()` method to carry out a validation check that is _not related to a specific field_. For example:

    
    input.Validator.Check(input.Password == input.ConfirmPassword, "Passwords do not match")
    

The `validator.AddError()` and `validator.AddFieldError()` methods also let you add validation errors directly:

    
    input.Validator.AddFieldError("Email", "This email address is already taken")
    input.Validator.AddError("Passwords do not match")
    

The `internal/validator/helpers.go` file also contains some helper functions to simplify validations that are not simple comparison operations.

`NotBlank(value string)`

Check that the value contains at least one non-whitespace character.

`MinRunes(value string, n int)`

Check that the value contains at least n runes.

`MaxRunes(value string, n int)`

Check that the value contains no more than n runes.

`Between(value, min, max T)`

Check that the value is between the min and max values inclusive.

`Matches(value string, rx *regexp.Regexp)`

Check that the value matches a specific regular expression.

`In(value T, safelist ...T)`

Check that a value is in a 'safelist' of specific values.

`AllIn(values []T, safelist ...T)`

Check that all values in a slice are in a 'safelist' of specific values.

`NotIn(value T, blocklist ...T)`

Check that the value is not in a 'blocklist' of specific values.

`NoDuplicates(values []T)`

Check that a slice does not contain any duplicate (repeated) values.

`IsEmail(value string)`

Check that the value has the formatting of a valid email address.

`IsURL(value string)`

Check that the value has the formatting of a valid URL.

For example, to use the `Between` check your code would look similar to this:

    
    input.Validator.CheckField(validator.Between(input.Age, 18, 30), "Age", "Age must between 18 and 30")
    

Feel free to add your own helper functions to the `internal/validator/helpers.go` file as necessary for your application.

Cookies
-------

The `internal/cookies` package provides helper functions for reading and writing cookies.

The `Write()` function base64-encodes the cookie value and checks the cookie length is no more than 4096 bytes before writing the cookie. You can use it like this:

    
    func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
        // Initialize a Go cookie as normal.
        cookie := http.Cookie{
            Name:     "exampleCookie",
            Value:    "Hello Zoë!",
            Path:     "/",
            MaxAge:   3600,
            HttpOnly: true,
            Secure:   true,
            SameSite: http.SameSiteLaxMode,
        }
    
        // Write the cookie.
        err := cookies.Write(w, cookie)
        if err != nil {
            app.serverError(w, r, err)
            return
        }
    
        ...
    }
    

The `Read()` function reads a named cookie and base64-decodes the value before returning it.

    
    func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
        // Read the cookie value and handle any errors as necessary for your application.
        value, err := cookies.Read(r, "exampleCookie")
        if err != nil {
            switch {
            case errors.Is(err, http.ErrNoCookie):
                app.badRequest(w, r, err)
            case errors.Is(err, cookies.ErrInvalidValue):
                app.badRequest(w, r, err)
            default:
                app.serverError(w, r, err)
            }
            return
        }
    
        ...
    }
    

The `internal/cookies` package also provides `WriteSigned()` and `ReadSigned()` functions for writing/reading signed cookies, and `WriteEncrypted()` and `ReadEncrypted()` functions encrypted cookies. Signed cookies are authenticated using HMAC-256, meaning that you can trust that the contents of the cookie has not been tampered with. Encrypted cookies are encrpyted using AES-GCM, which both authenticates and encrypts the cookie data, meaning that you can trust that the contents of the cookie has not been tampered with _and_ the contents of the cookie cannot be read by the client.

When using these helper functions, you must set your own (secret) key for signing and encryption. This key should be a random 32-character string generated using a CSRNG which you pass to the application using the `-cookie-key` command-line flag. For example:

    
    $ go run ./cmd/api --cookie-secret-key=heoCDWSgJ430OvzyoLNE9mVV9UJFpOWx
    

To write a new signed or encrypted cookie:

    
    func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
        // Initialize a Go cookie as normal.
        cookie := http.Cookie{
            Name:     "exampleCookie",
            Value:    "Hello Zoë!",
            Path:     "/",
            MaxAge:   3600,
            HttpOnly: true,
            Secure:   true,
            SameSite: http.SameSiteLaxMode,
        }
    
        // Write a signed cookie using WriteSigned() and passing in the secret key
        // as the final argument. Use WriteEncrypted() if you want an encrpyted
        // cookie instead.
        err := cookies.WriteSigned(w, cookie, app.config.cookie.secretKey)
        if err != nil {
            app.serverError(w, r, err)
            return
        }
    
        ...
    }
    

To read a signed or encrypted cookie:

    
    func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
        // Read the cookie value using ReadSigned() and passing in the secret key
        // as the final argument. Use ReadEncrypted() if you want to read an 
        // encrpyted cookie instead.
        value, err := cookies.ReadSigned(r, "exampleCookie", app.config.cookie.secretKey)
        if err != nil {
            switch {
            case errors.Is(err, http.ErrNoCookie):
                app.badRequest(w, r, err)
            case errors.Is(err, cookies.ErrInvalidValue):
                app.badRequest(w, r, err)
            default:
                app.serverError(w, r, err)
            }
            return
        }
    
        ...
    }
    

Changing the TLS certificates
-----------------------------

For convenience a self-signed TLS certificate (`cert.pem`) and private key (`key.pem`) are provided in the `tls` directory.

You can specify a different certificate and key at runtime using the `tls-cert-file` and `tls-key-file` command-line flags.

    
    $ go run . --tls-cert-file=/path/to/cert.pem --tls-key-file=/path/to/key.pem
    

Application version
-------------------

The application version number is defined in a `Get()` function in the `internal/version/version.go` file. Feel free to change this as necessary.

    
    package version
    
    func Get() string {
        return "0.0.1"
    }
    

Changing the module path
------------------------

The module path is currently set to `github.com/nezlobnaya/messing_with_autostrada`. Please find and replace all instances of `github.com/nezlobnaya/messing_with_autostrada` in the codebase with your own module path.